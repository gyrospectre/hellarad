[{"id":0,"href":"/squyre/functions/crowdstrike/","title":"CrowdStrike Falcon","parent":"Functions","content":"Summary     Indicator context from the CrowdStrike Falcon threat intelligence database. Also provides information on corporate hosts running the Falcon agent.\nRequires a paid Falcon Insight and Falcon X license.\nSupports     ipv4, domain, sha256, hostname\nExample Result     Found Falcon X indicator for 127.0.0.1: Malicious confidence: 'High'. Added: 2022-01-01 00:00:00 +0000 UTC Updated: 2022-01-01 00:00:10 +0000 UTC Labels: Killchain/C2,Malware/CobaltStrike Kill Chains: C2 Malware Families: CobaltStrike Vulnerabilities: Threat Types: Commodity,Criminal,RAT Targets: More information at: https://falcon.crowdstrike.com/search/?term=_all:~'127.0.0.1' Setup      Create a Falcon API key In AWS, create a new Secrets Manager secretcalled CrowdstrikeAPI in the same account/region as Squyre is deployed. Use the following content, obviously substituting your key and email. The secret should be of type Other type of secret.  { \u0026quot;ClientID\u0026quot;: \u0026lt;the Client ID of the API key you just created\u0026gt;, \u0026quot;ClientSecret\u0026quot;: \u0026lt;the Client Secret of the key\u0026gt;, \u0026quot;FalconCloud\u0026quot;: \u0026lt;the Falcon Cloud region your account uses e.g. us-1, us-2, eu-1, us-gov-1\u0026gt; } Environment Variables     ONLY_LOG_MATCHES : Set to true (in template.yaml) to only decorate an alert if the indicator was found in Falcon. Default=false.\n"},{"id":1,"href":"/squyre/architecture/","title":"Architecture","parent":"Squyre","content":""},{"id":2,"href":"/squyre/architecture/architecture/","title":"Architecture","parent":"Architecture","content":"Squyre is serverless, and uses AWS services SNS, Lambda and Step Functions to do it\u0026rsquo;s thing.\nAlerts are sent to the SNS topic, which triggers the first Lambda function, conductor. This function take the alert body, extracts IP addresses, domain names and hostnames, and then starts the step function with this information.\nThe step function (or state machine) then invokes enrichment functions depending on what sort of info was in the alert. There are currently two categories of functions:\n Multipurpose. These functions can enrich based on various data types, so are run on every alert. IPv4. These functions can only enrich IP addresses, so only run if the alert contained at least one IP.  Enrichment functions run in parallel, and then once everything is done the output is passed on to the final Lambda, output. This function is responsible for adding the results to the chosen destination (either Jira or Opsgenie) as comments.\nAll of this is deployed via Cloudformation, to make it easy to spin up and down.\n"},{"id":3,"href":"/squyre/usage/customise/","title":"Customising for your environment","parent":"Usage","content":"There are a couple of features which can be customised for your environment.\nEnrichment Functions     You can modify statemachine/enrich.asl.json to change which enrichment functions run. Don\u0026rsquo;t have CrowdStrike? No problem, just remove that component from the state machine. If you want, you can also remove unnecessary functions from template.yaml to cut down what gets deployed to AWS.\nThe easiest way to change the state machine definition is to edit it from the AWS Step Functions Workflow Studioin the AWS Console, then export as JSON back into statemachine/enrich.asl.json.\nHostname Enrichment     Squyre will attempt to extract any internal hostnames from your alerts. Most organisations have a convention for endpoints and servers, but they vary considerably. As a result, you need to tell Squyre what your org\u0026rsquo;s convention is.\nDo this via an environment variable in template.yaml under the ConductorFunction section, specifying a Go compatible regular expression.\nHOST_REGEX: A-[A-Z0-9]{6} The above example will match hostnames such as A-AB12CD.\nFiltering out internal domains     In most cases, you don\u0026rsquo;t want to enrich your internal domain names or email addresses, you\u0026rsquo;re only concerned with domains unrelated to your organisation. Again, via an environment variable in template.yaml in the ConductorFunction section, you can tell Squyre to ignore your domain.\nIGNORE_DOMAIN: your-internal-domain.int "},{"id":4,"href":"/squyre/usage/getting_started/","title":"Getting started","parent":"Usage","content":"There are a couple of ways you can deploy, either directly between your alert source and ticketing system (pattern 1), or using an incident management platform like Opsgenie (pattern 2).\nPattern 1 is the out of the box configuration as it\u0026rsquo;s the most generic. If you are using Splunk and Jira, but don\u0026rsquo;t already have something in place to create tickets automatically when alerts fire, then this is for you.\nPattern 2 however, is more scalable. If you are already using Opsgenie in your alert pipeline, this is a better option. This allows you to add as many alert sources as you like, without having to change anything on the Squyre side.\n"},{"id":5,"href":"/squyre/usage/incidentmgmt/","title":"Getting Started: Opsgenie Deployment","parent":"Usage","content":" Clone the repo.  git clone https://github.com/gyrospectre/squyre.git Install the AWS SAM CLI. Edit template.yaml to use OpsGenie instead of Jira. In the OutputFunction definition, change the CodeUri value to output/opsgenie. While you\u0026rsquo;re at it, add a second snippet to template.yaml, to allow Opsgenie to send to the SNS topic.   AlertTopicPolicy: Type: AWS::SNS::TopicPolicy Properties: PolicyDocument: Id: AlertTopicPolicy Version: 2012-10-17 Statement: - Sid: OpsGenie-Publish Effect: Allow Principal: AWS: arn:aws:iam::089311581210:root Action: sns:Publish Resource: \u0026quot;*\u0026quot; Topics: - !Ref AlertTopic With appropriate AWS credentials in your terminal session, build and deploy the stack. Name the stack sqyre.  sam build sam deploy --guided Create an OpsGenie integration API key. In AWS, create a new Secrets Manager secretcalled OpsGenieAPI in the same account/region as Squyre is deployed. Use the following content, obviously substituting your key and email. The secret should be of type Other type of secret.  { \u0026quot;apikey\u0026quot;: \u0026lt;the API key you just created\u0026gt; } Setup OpsGenie to send SNS messagesto topic squyre-Alert on alert creation only.  Next time an alert fires, the details will be sent to Squyre, which will add enrichment details back into the Opsgenie alert in the form of notes.\n"},{"id":6,"href":"/squyre/usage/direct/","title":"Getting Started: Splunk to Jira Deployment","parent":"Usage","content":" Clone the repo.  git clone https://github.com/gyrospectre/squyre.git Install the AWS SAM CLI. Update the consts at the top of output/jira/main.go with your destination Jira instance URL (BaseURL) and Project name (Project). With appropriate AWS credentials in your terminal session, build and deploy the stack. Name the stack squyre.  sam build sam deploy --guided  Over on Splunk, install the Splunk Add-on for AWS, which adds the ability to send alerts to SNS.\n  Configure the app with some AWS credentials. The IAM user or role must have SNS Publish/Get/List perms to SNS topic squyre-Alert.\n  Create a Jira API key.\n  In AWS, create a new Secrets Manager secretcalled JiraApi in the same account/region as Squyre is deployed. Use the following content, obviously substituting your key and email. The secret should be of type Other type of secret.\n  { \u0026quot;apikey\u0026quot;: \u0026lt;the API key you just created\u0026gt;, \u0026quot;user\u0026quot;: \u0026lt;the email address of the Jira account the key is associated with\u0026gt; } Almost there! Update one of your Splunk saved searches, adding a strcat at the end to combine all the fields you think are of use to a new field called interesting.  \u0026lt;awesome detection logic\u0026gt; | stats values(src_ip) as src_ip by dest_user | eval Detection=\u0026quot;A test alert\u0026quot; | strcat src_ip \u0026quot;,\u0026quot; dest_user interesting\nAdd an AWS SNS Alert action to your scheduled search, updating the Message field of the action to $result.interesting$. Also fill out the Account and Region fields per the AWS Tech Add-on documentation. The topic should be set to squyre-Alert.  Next time this alert fires, the details will be sent to Squyre, which will create a Jira ticket for you, adding enrichment details in the form of comments.\n"},{"id":7,"href":"/squyre/usage/requirements/","title":"Requirements","parent":"Usage","content":"You will need 3 things in place in order to use Squyre.\n  You must have an AWS account to host it. It runs solely in AWS using serverless services (lambdas and step functions). If you don\u0026rsquo;t have one, don\u0026rsquo;t be too concerned with signing up - if you\u0026rsquo;re only running a few test alerts through Squyre AWS \u0026ldquo;Free Tier\u0026rdquo;should mean the cost is negligible (if not free).\n  You need something that is generating security alerts for you. Well, obviously! Currently, we support Splunk or Opsgenie as alert sources. If you don\u0026rsquo;t use either, but your platform supports sending alerts to AWS SNS, raise an issue and we can look at adding support - should be fairly easy.\n  You need something capturing the steps taken to investigate alerts, like a ticketing system. This is commonly a task management platform like Jira, ServiceNow etc. We support Jira or Opsgenie as output providers right now.\n  "},{"id":8,"href":"/squyre/architecture/state/","title":"State Machine","parent":"Architecture","content":"The main state machine is called EnrichStateMachine, because it, uh enriches, and it\u0026rsquo;s a state machine.\nIt is defined by statemachine/enrich.asl.json in the AWS ASL language.\nLayout is straightforward, nested parallel branches run the enrichment tasks which are sent to the output function at the end to update alerts/tickets.\n"},{"id":9,"href":"/squyre/usage/","title":"Usage","parent":"Squyre","content":""},{"id":10,"href":"/squyre/functions/alienvaultotx/","title":"Alienvault OTX","parent":"Functions","content":"Summary     Indicator context from the Alienvault OTXthreat intelligence community.\nNo API key is required for lookups.\nSupports     ipv4, domain, url\nExample Result     Alienvault OTX has 1 matches for '127.0.0.1', in the following pulses: IPQS Abusive IP List More information at: https://otx.alienvault.com/browse/global/pulses?q=127.0.0.1 Setup     No setup required.\nEnvironment Variables     ONLY_LOG_MATCHES : Set to true (in template.yaml) to only decorate an alert if the indicator was found in Alienvault OTX. Default=false.\n"},{"id":11,"href":"/squyre/functions/","title":"Functions","parent":"Squyre","content":""},{"id":12,"href":"/squyre/functions/greynoise/","title":"Greynoise","parent":"Functions","content":"Summary     Data on IP addresses associated with opportunistic internet scanning or common business services, not targeted threats. For more information, check out https://www.greynoise.io/.\nThis function uses the free community API, so no key is required.\nSupports     ipv4\nExample Result     Greynoise believes 127.0.0.1 is malicious. Noise? true In the RIOT database? false Last seen 2022-02-06. More information at: https://viz.greynoise.io/ip/127.0.0.1 Setup     No setup required.\nEnvironment Variables     ONLY_LOG_MATCHES : Set to true (in template.yaml) to only decorate an alert if the indicator was found in Greynoise. Default=false.\n"},{"id":13,"href":"/squyre/functions/ipapi/","title":"IP API","parent":"Functions","content":"Summary     Geolocation data on IP addresses from https://ip-api.com/. This service is free for non-commercial use, which is the only form currently supported by this function. If you find IP API useful and would like to use it in a commercial environment, I\u0026rsquo;d encourage you to subscribe.\nSupports     ipv4\nExample Result     IP API result for 127.0.0.1 (Dynamic distribution IPs for broadband services): Country: Russia City: Baltiysk, Kaliningrad Oblast ISP: Rostelecom networks Setup     No setup required.\n"},{"id":14,"href":"/squyre/contrib/","title":"Developing","parent":"Squyre","content":"Data Structures     squyre.Alert - The main data structure used by Squyre. It encapsulates everything about an alert, it\u0026rsquo;s details and the enrichment results. Alerts are the standard way data is passed around between components.\nsquyre.Subject - Any collection of data points which can be used for enrichment. At the time of writing, either an IP address or a domain name. Subjects are stored within Alerts.\nsquyre.Result - Stores enrichment results, the subject used, and the source of the data. Results are also stored within Alerts.\nEnrichment Functions     An enrichment function is a Go lambda that takes a squyre.Alert as input (see squyre.go), performs some analysis, adds the results (as a slice of squyre.Result objects) to the Alert object, and returns a Json string representation of the updated Alert.\nHave a look at any of the existing functions (in the function) folder, you should be able to copy paste a fair amount and get started pretty quick. If you need to work with API keys, please use AWS Secrets Manager to store your secrets; there is a built in function to fetch keys as required! For E.g. https://github.com/gyrospectre/squyre/blob/0ad801155f278d0e02894bd312eb4f0da2387341/output/jira/main.go#L49Once you have something working, add the new function to the template.yaml (again copy one of the other stanzas) and then test:\nmake fmt make lint make test make build sam local invoke MyNewFunction --event event/alert.json If all is working, then add the new function to the statemachine/enrich.asl.json file, so that it executes as part of the main workflow. Then you can sam deploy and try it out!\nTesting     Run Go unit tests\nmake test Integration tests (requires AWS credentials in session, live calls)\nmake build # Test enrichment functions sam local invoke IPAPIFunction --event event/ip-alert.json sam local invoke GreynoiseFunction --event event/ip-alert.json # Test Conductor from both potential sources of the SNS sam local invoke ConductorFunction --event event/sns_from_splunk.json sam local invoke ConductorFunction --event event/sns_from_opsgenie.json # Test whichever output function you're using (either Jira or Opsgenie) sam local invoke OutputFunction --event event/output.json "},{"id":15,"href":"/squyre/overview/","title":"Overview","parent":"Squyre","content":"testt\n"},{"id":16,"href":"/squyre/","title":"Squyre","parent":"","content":"Easy alert enrichment for overworked security teams!\nSquyre will help you deal with threats more effectively, decorating your security alerts by adding helpful information that provides context and helps you decide if this alert is cause for concern.\nThe Problem     Once beyond the earliest stages of maturity, Security teams build processes to generate alerts to tell them when threats may be active in their environment. These alerts must be \u0026ldquo;triaged\u0026rdquo; by an analyst; as in, deciding which of the following applies.\n \u0026ldquo;false positive\u0026rdquo; the alert was triggered by an event that it was not designed to catch \u0026ldquo;true positive benign\u0026rdquo; the alert was triggered by the intended event, but the activity is acceptable and does not require further action. \u0026ldquo;true positive malicious\u0026rdquo; the alert was triggered by the intended event. It\u0026rsquo;s bad and we need to call an incident!  The goal of threat detection is to be as accurate as possible with the last category, and minimise the other two. Unfortunately this is quite difficult! Enterprise environments are complex, and they have lots of humans doing complex stuff in them; you will always have some level of false positives/true positive benign alerts.\nUnfortunately, alerts of these undesirable types can be quite hard on the analyst! Alerts almost never contain all the information needed to be able to triage. An analyst will perform research on the host, IP address, file hash etc in the alert, trying to get context on what all of this information means and whether it means something bad has happened. This is time consuming and requires switching to numerous tools, websites etc to gather various parts of the puzzle.\nAt scale, this leads to \u0026ldquo;alert fatigue\u0026rdquo;: de-sensitising analysts with repetitive tasks, leading to missed or ignored alerts or delayed responses. It\u0026rsquo;s also not much fun! Poor alert quality leads to frustrated security teams that are not very happy and likely to leave.\nOur Solution     Ryan McGeehan\u0026rsquo;s 2017 article \u0026ldquo;Lessons Learned in Detection Engineering\u0026rdquo;is one I keep coming back to - go read it if you haven\u0026rsquo;t! In Ryan\u0026rsquo;s words:\n\u0026ldquo;Great teams prepare the on-call analyst with as much information as possible.\u0026quot; \u0026hellip; \u0026ldquo;You should decorate alerts. This describes a standard of detail where an alert brings additional information to the analyst without requiring extra work. This helps avoids “tab hell” where an analyst needs to be logged into several tools to follow up on an incident, just to know what is going on.\u0026quot; \u0026hellip; \u0026ldquo;A rule should trigger automation that pulls in corresponding information, including log snippets, translation of IDs or employee names, hostnames, opinions from threat intelligence, etc.\u0026quot;\nThis is exactly what Squyre does for you. Automation runs to gather this information and add to your alert - \u0026ldquo;decorating\u0026rdquo; them.\nIt is cheap and relatively easy to run, improving your ability to catch threats, and keeping your team happy and focussed on what you pay them for! There are commercial products out there to do this, but they can get VERY expensive.\nThat\u0026rsquo;s the goal of the project - put good alert management into everyone\u0026rsquo;s reach, regardless of their company\u0026rsquo;s size or budget.\n"},{"id":17,"href":"/squyre/tags/","title":"Tags","parent":"Squyre","content":""}]